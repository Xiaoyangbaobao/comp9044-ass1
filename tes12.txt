bash -n mygive-* *.sh # mygive-add
check_hashbang.sh mygive-* # mygive-add
check_features_used.sh mygive-* # mygive-add
shellcheck -x -a -P='.' --shell=dash  -e2010,2011,2012,2038 mygive-*; true # mygive-add

In mygive-mark line 43:
    for test_file in $base_dir/tests/*; do
                     ^-------^ SC2231 (info): Quote expansions in this for loop glob to prevent wordsplitting, e.g. "$dir"/*.txt .


In mygive-mark line 44:
        test_dir=$(basename $test_file | cut -d'.' -f1)
                            ^--------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
        test_dir=$(basename "$test_file" | cut -d'.' -f1)


In mygive-mark line 55:
            file_name=$(basename $file_dir)
                                 ^-------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
            file_name=$(basename "$file_dir")


In mygive-mark line 58:
            stdout=""
            ^----^ SC2034 (warning): stdout appears unused. Verify use (or export if used externally).


In mygive-mark line 61:
            stderr=""
            ^----^ SC2034 (warning): stderr appears unused. Verify use (or export if used externally).


In mygive-mark line 75:
                if ! echo "$arguments" | grep -Eq "$arguments_regex"; then
                                                   ^--------------^ SC2154 (warning): arguments_regex is referenced but not assigned.


In mygive-mark line 100:
                ./"$program_file" $arguments >"$result_stdout_file" 2>"$result_stderr_file"
                                  ^--------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
                ./"$program_file" "$arguments" >"$result_stdout_file" 2>"$result_stderr_file"


In mygive-mark line 102:
                echo "$stdin" | ./"$program_file" $arguments >"$result_stdout_file" 2>"$result_stderr_file"
                                                  ^--------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
                echo "$stdin" | ./"$program_file" "$arguments" >"$result_stdout_file" 2>"$result_stderr_file"


In mygive-mark line 146:
            if [ $? -eq 0 ] && diff -q $expected_stderr_file $result_stderr_file >/dev/null && [ "$result_exit_code" -eq "$exit_status" ]; then
                 ^-- SC2181 (style): Check exit code directly with e.g. 'if mycmd;', not indirectly with $?.
                                       ^-------------------^ SC2086 (info): Double quote to prevent globbing and word splitting.
                                                             ^-----------------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
            if [ $? -eq 0 ] && diff -q "$expected_stderr_file" "$result_stderr_file" >/dev/null && [ "$result_exit_code" -eq "$exit_status" ]; then


In mygive-mark line 219:
                if diff -q $expected_stderr_file $result_stderr_file >/dev/null; then
                           ^-------------------^ SC2086 (info): Double quote to prevent globbing and word splitting.
                                                 ^-----------------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
                if diff -q "$expected_stderr_file" "$result_stderr_file" >/dev/null; then


In mygive-status line 13:
        ass_name=$(basename $ass)
                            ^--^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
        ass_name=$(basename "$ass")


In mygive-status line 18:
                submission_num=$(basename $submission)
                                          ^---------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
                submission_num=$(basename "$submission")


In mygive-submit line 50:
    cp "$file_name" .mygive/"$ass_name"/"$zid"/"1"  && date "+%a %b %e %T %Y" > ".mygive/""$ass_name""/""$zid""/"1"/.timestamp"
                                                                                                                 ^-- SC2140 (warning): Word is of the form "A"B"C" (B indicated). Did you mean "ABC" or "A\"B\"C"?


In mygive-test line 32:
for test_file in .mygive/$ass_name/tests/*; do
                         ^-------^ SC2231 (info): Quote expansions in this for loop glob to prevent wordsplitting, e.g. "$dir"/*.txt .


In mygive-test line 33:
    test_dir=$(basename $test_file | cut -d'.' -f1)
                        ^--------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
    test_dir=$(basename "$test_file" | cut -d'.' -f1)


In mygive-test line 45:
        file_name=$(basename $file_dir)
                             ^-------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
        file_name=$(basename "$file_dir")


In mygive-test line 48:
        stdout=""
        ^----^ SC2034 (warning): stdout appears unused. Verify use (or export if used externally).


In mygive-test line 51:
        stderr=""
        ^----^ SC2034 (warning): stderr appears unused. Verify use (or export if used externally).


In mygive-test line 84:
            ./"$program_file" $arguments >"$result_stdout_file" 2>"$result_stderr_file"
                              ^--------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
            ./"$program_file" "$arguments" >"$result_stdout_file" 2>"$result_stderr_file"


In mygive-test line 86:
            echo "$stdin" | ./"$program_file" $arguments >"$result_stdout_file" 2>"$result_stderr_file"
                                              ^--------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
            echo "$stdin" | ./"$program_file" "$arguments" >"$result_stdout_file" 2>"$result_stderr_file"


In mygive-test line 129:
        if [ $? -eq 0 ] && diff -q $expected_stderr_file $result_stderr_file >/dev/null && [ "$result_exit_code" -eq "$exit_status" ]; then
             ^-- SC2181 (style): Check exit code directly with e.g. 'if mycmd;', not indirectly with $?.
                                   ^-------------------^ SC2086 (info): Double quote to prevent globbing and word splitting.
                                                         ^-----------------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
        if [ $? -eq 0 ] && diff -q "$expected_stderr_file" "$result_stderr_file" >/dev/null && [ "$result_exit_code" -eq "$exit_status" ]; then


In mygive-test line 202:
            if diff -q $expected_stderr_file $result_stderr_file >/dev/null; then
                       ^-------------------^ SC2086 (info): Double quote to prevent globbing and word splitting.
                                             ^-----------------^ SC2086 (info): Double quote to prevent globbing and word splitting.

Did you mean: 
            if diff -q "$expected_stderr_file" "$result_stderr_file" >/dev/null; then

For more information:
  https://www.shellcheck.net/wiki/SC2034 -- stderr appears unused. Verify use...
  https://www.shellcheck.net/wiki/SC2140 -- Word is of the form "A"B"C" (B in...
  https://www.shellcheck.net/wiki/SC2154 -- arguments_regex is referenced but...
Test 1_add (add: 1 assignment) - passed
Test 2_add (add: existing assignment) - passed
Test 3_add (add: incorrect number of arguments) - passed
Test 4_add (add: stdout if tests file doesn't exist) - passed
Test 5_add (add: stderr if tests file doesn't exist) - passed
Test 6_add (add: invalid name) - passed
Test 7_summary (summary: 1 assignment) - passed
Test 8_submit (submit) - passed
Test 9_submit (submit: error handling) - passed
Test 10_status (status 1 assignment) - passed
Test 11_fetch (fetch) - passed
Test 12_fetch (fetch - no submission number) - passed
Test 13_fetch (fetch - negative submission number) - passed
Test 14_fetch (fetch error) - passed
Test 15_test (test) - passed
Test 16_test (test: argument error handling) - passed
Test 17_mark (mark 1 assignment) - passed
Test 18_summary (rm) - passed
Test 19_summary (add,rm,add) - passed
Test 20_mark (test newline handling) - passed
Test 21_mark (test option handling) - passed
Test 22_mark (test stdin & argument handling handling) - passed
Test 23_test (test incorrect stderr & incorrect exit) - passed
Test 24_test (test incorrect stderr with no new line + incorrect exit) - passed
Test 25_mark (test incorrect stderr & incorrect exit) - passed
25 tests passed 0 tests failed 
